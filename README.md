# PathFinderVisualizer

I am creating this visualizer as my **2nd year** college project.
It has a simple and elegant design, nothing fancy, I hope you like it :)

You can see the project here *link*

## Algorithms Used

```Weighted Algorithms```
* **Dijkstra's Algorithm** : Dijkstra's algorithm (or Dijkstra's Shortest Path First algorithm) is an algorithm for finding the shortest paths between nodes in a graph. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later. **Guarantees the shortest path**.

* **A-Star Search** : A* is a graph traversal and path search algorithm, which is often used in many fields of computer science due to its completeness, optimality, and optimal efficiency. It uses heuristics to **guarantee the shortest path** much faster than Dijkstra's Algorithm.

* **Greedy Best-first Search** : Best-first search is a search algorithm which explores a graph by expanding the most promising node chosen according to a specified rule. **Does not guarantee the shortest-path**.

* **Swarm Algorithm** : A mixture of Dijkstra's Algorithm and A*. **Does not guarantee the shortest-path**.

* **Convergent Swarm Algorithm** : The faster, more heuristic-heavy version of Swarm. **Does not guarantee the shortest-path**.

* **Bidirectional Swarm Algorithm** : Swarm from both sides. **Does not guarantee the shortest path**.

* **Jump Point Search** : Jump Point Search (JPS) is an optimization to the A* search algorithm for uniform-cost grids. It reduces symmetries in the search procedure by means of graph pruning.

```Non-Weighted Algorithms```
* **Breath-first Search** : Breadth-first search is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root, and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. **Guarantees the shortest path**.

* **Depth-first Search** : Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking. **Does not guarantee the shortest path**.


## Different Mazes

* **Basic Random Maze**
* **Recursive Division**
* **Recursive Division (Vertical Skew)**
* **Recursive Division (Horizontal Skew)**
* **Simple Spiral**
* **Simple Stair Pattern**



<br>
(https://github-readme-stats.vercel.app/api?username=hashikano)](https://github.com/anuraghazra/github-readme-stats)
